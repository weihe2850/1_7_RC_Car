// Generated by gencpp from file race_car_pkg/CarStates.msg
// DO NOT EDIT!


#ifndef RACE_CAR_PKG_MESSAGE_CARSTATES_H
#define RACE_CAR_PKG_MESSAGE_CARSTATES_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace race_car_pkg
{
template <class ContainerAllocator>
struct CarStates_
{
  typedef CarStates_<ContainerAllocator> Type;

  CarStates_()
    : Ux_mps(0.0)
    , Uy_mps(0.0)
    , r_radps(0.0)
    , ax_mps2(0.0)
    , ay_mps2(0.0)
    , speed_rpm(0.0)
    , delta_rad(0.0)
    , Single_Motor_TxR_Nm(0.0)
    , latitude(0.0)
    , longitude(0.0)
    , altitude(0.0)
    , roll_rad(0.0)
    , pitch_rad(0.0)
    , yaw_rad(0.0)
    , gps_state(0)
    , UWB_x_m(0.0)
    , UWB_y_m(0.0)
    , EKF_x_m(0.0)
    , EKF_y_m(0.0)  {
    }
  CarStates_(const ContainerAllocator& _alloc)
    : Ux_mps(0.0)
    , Uy_mps(0.0)
    , r_radps(0.0)
    , ax_mps2(0.0)
    , ay_mps2(0.0)
    , speed_rpm(0.0)
    , delta_rad(0.0)
    , Single_Motor_TxR_Nm(0.0)
    , latitude(0.0)
    , longitude(0.0)
    , altitude(0.0)
    , roll_rad(0.0)
    , pitch_rad(0.0)
    , yaw_rad(0.0)
    , gps_state(0)
    , UWB_x_m(0.0)
    , UWB_y_m(0.0)
    , EKF_x_m(0.0)
    , EKF_y_m(0.0)  {
  (void)_alloc;
    }



   typedef double _Ux_mps_type;
  _Ux_mps_type Ux_mps;

   typedef double _Uy_mps_type;
  _Uy_mps_type Uy_mps;

   typedef double _r_radps_type;
  _r_radps_type r_radps;

   typedef double _ax_mps2_type;
  _ax_mps2_type ax_mps2;

   typedef double _ay_mps2_type;
  _ay_mps2_type ay_mps2;

   typedef double _speed_rpm_type;
  _speed_rpm_type speed_rpm;

   typedef double _delta_rad_type;
  _delta_rad_type delta_rad;

   typedef double _Single_Motor_TxR_Nm_type;
  _Single_Motor_TxR_Nm_type Single_Motor_TxR_Nm;

   typedef double _latitude_type;
  _latitude_type latitude;

   typedef double _longitude_type;
  _longitude_type longitude;

   typedef double _altitude_type;
  _altitude_type altitude;

   typedef double _roll_rad_type;
  _roll_rad_type roll_rad;

   typedef double _pitch_rad_type;
  _pitch_rad_type pitch_rad;

   typedef double _yaw_rad_type;
  _yaw_rad_type yaw_rad;

   typedef int32_t _gps_state_type;
  _gps_state_type gps_state;

   typedef double _UWB_x_m_type;
  _UWB_x_m_type UWB_x_m;

   typedef double _UWB_y_m_type;
  _UWB_y_m_type UWB_y_m;

   typedef double _EKF_x_m_type;
  _EKF_x_m_type EKF_x_m;

   typedef double _EKF_y_m_type;
  _EKF_y_m_type EKF_y_m;





  typedef boost::shared_ptr< ::race_car_pkg::CarStates_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::race_car_pkg::CarStates_<ContainerAllocator> const> ConstPtr;

}; // struct CarStates_

typedef ::race_car_pkg::CarStates_<std::allocator<void> > CarStates;

typedef boost::shared_ptr< ::race_car_pkg::CarStates > CarStatesPtr;
typedef boost::shared_ptr< ::race_car_pkg::CarStates const> CarStatesConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::race_car_pkg::CarStates_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::race_car_pkg::CarStates_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::race_car_pkg::CarStates_<ContainerAllocator1> & lhs, const ::race_car_pkg::CarStates_<ContainerAllocator2> & rhs)
{
  return lhs.Ux_mps == rhs.Ux_mps &&
    lhs.Uy_mps == rhs.Uy_mps &&
    lhs.r_radps == rhs.r_radps &&
    lhs.ax_mps2 == rhs.ax_mps2 &&
    lhs.ay_mps2 == rhs.ay_mps2 &&
    lhs.speed_rpm == rhs.speed_rpm &&
    lhs.delta_rad == rhs.delta_rad &&
    lhs.Single_Motor_TxR_Nm == rhs.Single_Motor_TxR_Nm &&
    lhs.latitude == rhs.latitude &&
    lhs.longitude == rhs.longitude &&
    lhs.altitude == rhs.altitude &&
    lhs.roll_rad == rhs.roll_rad &&
    lhs.pitch_rad == rhs.pitch_rad &&
    lhs.yaw_rad == rhs.yaw_rad &&
    lhs.gps_state == rhs.gps_state &&
    lhs.UWB_x_m == rhs.UWB_x_m &&
    lhs.UWB_y_m == rhs.UWB_y_m &&
    lhs.EKF_x_m == rhs.EKF_x_m &&
    lhs.EKF_y_m == rhs.EKF_y_m;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::race_car_pkg::CarStates_<ContainerAllocator1> & lhs, const ::race_car_pkg::CarStates_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace race_car_pkg

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::race_car_pkg::CarStates_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::race_car_pkg::CarStates_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::race_car_pkg::CarStates_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::race_car_pkg::CarStates_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::race_car_pkg::CarStates_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::race_car_pkg::CarStates_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::race_car_pkg::CarStates_<ContainerAllocator> >
{
  static const char* value()
  {
    return "8e4453ced50b304c0ba0c546d7acd617";
  }

  static const char* value(const ::race_car_pkg::CarStates_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x8e4453ced50b304cULL;
  static const uint64_t static_value2 = 0x0ba0c546d7acd617ULL;
};

template<class ContainerAllocator>
struct DataType< ::race_car_pkg::CarStates_<ContainerAllocator> >
{
  static const char* value()
  {
    return "race_car_pkg/CarStates";
  }

  static const char* value(const ::race_car_pkg::CarStates_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::race_car_pkg::CarStates_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float64 Ux_mps\n"
"float64 Uy_mps\n"
"float64 r_radps\n"
"float64 ax_mps2\n"
"float64 ay_mps2\n"
"float64 speed_rpm\n"
"float64 delta_rad\n"
"float64 Single_Motor_TxR_Nm\n"
"float64 latitude\n"
"float64 longitude\n"
"float64 altitude\n"
"float64 roll_rad\n"
"float64 pitch_rad\n"
"float64 yaw_rad\n"
"int32 gps_state\n"
"float64 UWB_x_m\n"
"float64 UWB_y_m\n"
"float64 EKF_x_m\n"
"float64 EKF_y_m\n"
;
  }

  static const char* value(const ::race_car_pkg::CarStates_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::race_car_pkg::CarStates_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.Ux_mps);
      stream.next(m.Uy_mps);
      stream.next(m.r_radps);
      stream.next(m.ax_mps2);
      stream.next(m.ay_mps2);
      stream.next(m.speed_rpm);
      stream.next(m.delta_rad);
      stream.next(m.Single_Motor_TxR_Nm);
      stream.next(m.latitude);
      stream.next(m.longitude);
      stream.next(m.altitude);
      stream.next(m.roll_rad);
      stream.next(m.pitch_rad);
      stream.next(m.yaw_rad);
      stream.next(m.gps_state);
      stream.next(m.UWB_x_m);
      stream.next(m.UWB_y_m);
      stream.next(m.EKF_x_m);
      stream.next(m.EKF_y_m);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct CarStates_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::race_car_pkg::CarStates_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::race_car_pkg::CarStates_<ContainerAllocator>& v)
  {
    s << indent << "Ux_mps: ";
    Printer<double>::stream(s, indent + "  ", v.Ux_mps);
    s << indent << "Uy_mps: ";
    Printer<double>::stream(s, indent + "  ", v.Uy_mps);
    s << indent << "r_radps: ";
    Printer<double>::stream(s, indent + "  ", v.r_radps);
    s << indent << "ax_mps2: ";
    Printer<double>::stream(s, indent + "  ", v.ax_mps2);
    s << indent << "ay_mps2: ";
    Printer<double>::stream(s, indent + "  ", v.ay_mps2);
    s << indent << "speed_rpm: ";
    Printer<double>::stream(s, indent + "  ", v.speed_rpm);
    s << indent << "delta_rad: ";
    Printer<double>::stream(s, indent + "  ", v.delta_rad);
    s << indent << "Single_Motor_TxR_Nm: ";
    Printer<double>::stream(s, indent + "  ", v.Single_Motor_TxR_Nm);
    s << indent << "latitude: ";
    Printer<double>::stream(s, indent + "  ", v.latitude);
    s << indent << "longitude: ";
    Printer<double>::stream(s, indent + "  ", v.longitude);
    s << indent << "altitude: ";
    Printer<double>::stream(s, indent + "  ", v.altitude);
    s << indent << "roll_rad: ";
    Printer<double>::stream(s, indent + "  ", v.roll_rad);
    s << indent << "pitch_rad: ";
    Printer<double>::stream(s, indent + "  ", v.pitch_rad);
    s << indent << "yaw_rad: ";
    Printer<double>::stream(s, indent + "  ", v.yaw_rad);
    s << indent << "gps_state: ";
    Printer<int32_t>::stream(s, indent + "  ", v.gps_state);
    s << indent << "UWB_x_m: ";
    Printer<double>::stream(s, indent + "  ", v.UWB_x_m);
    s << indent << "UWB_y_m: ";
    Printer<double>::stream(s, indent + "  ", v.UWB_y_m);
    s << indent << "EKF_x_m: ";
    Printer<double>::stream(s, indent + "  ", v.EKF_x_m);
    s << indent << "EKF_y_m: ";
    Printer<double>::stream(s, indent + "  ", v.EKF_y_m);
  }
};

} // namespace message_operations
} // namespace ros

#endif // RACE_CAR_PKG_MESSAGE_CARSTATES_H
